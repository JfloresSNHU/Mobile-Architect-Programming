The goal of the mobile application I developed—Weight Trackit—was to provide users with a simple, intuitive way to log their weight, track progress over time, and stay motivated by setting and reaching personal goals. The app was specifically designed to meet the needs of users who want a lightweight and privacy-focused tool to manage their health data without unnecessary complexity or clutter. By incorporating core features like daily weight entry, goal setting, real-time updates via Firebase, and SMS notifications when users hit their targets, the app offers both practical value and personalized feedback to support users on their wellness journeys.

To achieve a user-centered experience, the app included a clean login screen, a dashboard for viewing and managing weight logs, a form for adding new entries, and a screen for setting weight goals. Each screen was intentionally designed with clarity and accessibility in mind—using large buttons, simple layouts, and familiar navigation patterns. The dashboard displayed recent weight entries in a RecyclerView with clearly labeled columns and a bold “Delete” button, keeping interactions straightforward. I also ensured users weren’t overwhelmed by unnecessary features or permissions, maintaining trust and usability. The design choices proved effective, as they directly addressed the user's need for a minimal and purposeful health-tracking experience.

When it came to coding, I used a modular approach, focusing on one feature or screen at a time while ensuring each part integrated cleanly with the others. I leveraged Firebase Authentication and Realtime Database, and practiced defensive coding strategies like null checks and permission handling for SMS to avoid runtime crashes. This methodical process made the app easier to test and debug. I continuously tested each module using the Android Studio emulator and log outputs, validating both user flows and backend interactions. This testing process was essential, revealing a few overlooked elements such as permission declarations and layout constraints that were quickly resolved.

Throughout the entire app development lifecycle—from the initial wireframing and layout planning to feature implementation and final polish—I encountered several challenges that required creative solutions. One key example was customizing the logout functionality and header layout to replace the default ActionBar and maintain full visual control. In doing so, I gained deeper insight into layout hierarchies and constraint-based design in Android. Among all components, I was especially proud of the goal-checking and SMS notification feature, which combined backend logic with user-triggered actions to create a responsive, real-world functionality. This not only demonstrated my ability to integrate third-party services securely but also showcased a thoughtful application of user-centric design and technical execution.

